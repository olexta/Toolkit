// The following code was generated by Microsoft Visual Studio 2005.
// The test owner should check each test for validity.
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using Toolkit.RPL.Factories;
using System.Runtime.Remoting;

namespace Toolkit.RPL.Test
{
/// <summary>
/// This is a test class for RPL.Storage.ODB and is intended
/// to contain all RPL.Storage.ODB Unit Tests
/// </summary>
[TestClass()]
public class ODBTest
{
	private static string  m_obj_name = "VS_Load_Test";
	private TestContext testContextInstance;

	/// <summary>
	/// Gets or sets the test context which provides
	/// information about and functionality for the current test run.
	/// </summary>
	public TestContext TestContext
	{
		get
		{
			return testContextInstance;
		}
		set
		{
			testContextInstance = value;
		}
	}
	#region Additional test attributes
	// 
	// You can use the following additional attributes as you write your tests:
	//
	
	// Use ClassInitialize to run code before running the first test in the class
	
	[ClassInitialize()]
	public static void MyClassInitialize(TestContext testContext)
	{
		RemotingConfiguration rc = RemotingConfiguration.Instance;
	}
	
	// Use ClassCleanup to run code after all tests in a class have run
	
	[ClassCleanup()]
	public static void MyClassCleanup()
	{
		PersistenceBroker.Close();
	}
	
	#endregion

	[Priority( 1 ), TestMethod()]
	public void SaveRetriveSearchTest()
	{
		// common variables
		TestObject obj;
		RetrieveCriteria ret_crit;
		int _id_expected;
		string _name_expected;
		DateTime _stamp_expected;

		string _string_expected;
		int? _int_expected;
		bool? _boolean_expected;
		double? _double_expected;
		DateTime? _datetime_expected;


		obj = new TestObject();
		_name_expected = obj.Name = m_obj_name + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
		_int_expected = obj._int = 1234567890;
		_boolean_expected = obj._bool = true;
		_string_expected = obj._string = 
			@"Test строка (ї,ё) 1@№" + DateTime.Now.ToString();
		obj._datetime = DateTime.Now;
		_double_expected = obj._double = (double) 1 / 33;
		
		// create parent object
		TestObject parent = new TestObject();
		parent.Name = _name_expected;
		parent._int = _int_expected;
		//end
		obj.Parents.Add( parent );
		obj.Save(); //save object
	

		// save data here because of change that can be during conversion to sql pressision
		_datetime_expected = obj._datetime;
		_id_expected = obj.ID;
		_stamp_expected = obj.Stamp;

		#region check props after save
		Assert.AreEqual( _name_expected, obj.Name );
		Assert.AreEqual( _int_expected, obj._int );
		Assert.AreEqual( _boolean_expected, obj._bool );
		Assert.AreEqual( _string_expected, obj._string);
		Assert.IsTrue( DateTime.Equals( _stamp_expected, obj.Stamp ));
		Assert.AreEqual( _double_expected, obj._double );
		// parent check
		foreach (PersistentObject link_obj in obj.Parents ) {
			Assert.AreEqual(_name_expected, link_obj.Name );
		}
		#endregion
		
		// by string equality
		ret_crit = 
			new RetrieveCriteria( 
				(new TestObject()).Type, 
				"(_string = '" + _string_expected +"')" );
		ret_crit.Perform();
		Assert.IsTrue( ( ret_crit.CountFound == 1 ), "Search by _string failed");
		Assert.AreEqual( _id_expected, ret_crit[0].ID );
		// check properties
		Assert.AreEqual( _name_expected, ((TestObject)ret_crit[0]).Name );
		Assert.AreEqual( _int_expected, ((TestObject)ret_crit[0])._int );
		Assert.AreEqual( _boolean_expected, ((TestObject)ret_crit[0])._bool );
		Assert.AreEqual( _string_expected, ((TestObject)ret_crit[0])._string );
		Assert.AreEqual( _stamp_expected, ((TestObject)ret_crit[0]).Stamp );
		Assert.AreEqual( _datetime_expected, ((TestObject)ret_crit[0])._datetime );
		Assert.AreEqual( _double_expected, ((TestObject)ret_crit[0])._double );

		// by LIKE
		ret_crit = 
			new RetrieveCriteria( 
				(new TestObject()).Type, 
				"( _string LIKE '%" + 
				_string_expected.Substring( 2, _string_expected.Length - 2 ) + 
				"%')" );
		ret_crit.Perform();
		Assert.IsTrue( ( ret_crit.CountFound == 1 ), "Search by 'Like' failed");
		Assert.AreEqual( _id_expected, ret_crit[0].ID );
		
		// by string NOT LIKE
		ret_crit = new RetrieveCriteria( 
			(new TestObject()).Type, 
			"( _string NOT LIKE '%" + 
			_string_expected.Substring( 2, _string_expected.Length - 2 ) + 
			"%')" );
		ret_crit.Perform();
		bool found = false;
		int i = 0;
		
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) {
				found = true;
				break;
			}
			i++;
		}
		Assert.IsFalse( found, "Search by 'NOT LIKE' failed" );

		// by ID
		ret_crit = new RetrieveCriteria( 
			(new TestObject()).Type, 
			"( ID = " + _id_expected + ")" );
		ret_crit.Perform();
		Assert.IsTrue( ( ret_crit.CountFound == 1 ), "Search by id failed");
		Assert.AreEqual( _id_expected, ret_crit[0].ID );

		// by NOT ID
		ret_crit = new RetrieveCriteria( 
			(new TestObject()).Type, 
			"( ID <> " + _id_expected + ")" );
		ret_crit.Perform();
		found = false;
		i = 0;
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) { 
				found = true;
				break;
			}
			i++;
		}
		Assert.IsFalse( found, "search by '<> ID' condition failed" );

		// by bit
		ret_crit = new RetrieveCriteria( 
			(new TestObject()).Type,
			"( _bool = CAST(" + ((bool)_boolean_expected ? 1 : 0) + " as bit))" );
		ret_crit.Perform();
		found = false;
		i = 0;
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) {
				found = true;
				break;
			}
			i++;
		}
		Assert.IsTrue( found, "search by _bool failed" );

		// by <> bit
		ret_crit = new RetrieveCriteria( 
			(new TestObject()).Type, 
			"( _bool <> CAST(" + ((bool)_boolean_expected ? 1 : 0) + " as bit))" );
		ret_crit.Perform();
		found = false;
		i = 0;
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) {
				found = true;
				break;
			}
			i++;
		}
		Assert.IsFalse( found, "search by '<> _bool' failed" );

		#region
		// by int
		ret_crit = new RetrieveCriteria( 
			(new TestObject()).Type, 
			"( _int = " + _int_expected + ")" );
		ret_crit.Perform();
		found = false;
		i = 0;
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) {
				found = true;
				break;
			}
			i++;
		}
		Assert.IsTrue( found, "search by _int failed" );

		// by <> int
		ret_crit = new RetrieveCriteria(
			(new TestObject()).Type, 
			"( _int <> " + _int_expected + ")" );
		ret_crit.Perform();
		found = false;
		i = 0;
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) {
				found = true;
				break;
			}
			i++;
		}
		Assert.IsFalse( found, "search by '<> _int' condition failed" );
		#endregion

		// by datetime
		ret_crit = new RetrieveCriteria( 
			(new TestObject()).Type,
			"( _datetime = CAST('" + 
			_datetime_expected.Value.ToString( "yyyy-MM-dd HH:mm:ss.fff" ) + 
			"' as datetime))" );
		ret_crit.Perform();
		found = false;
		i = 0;
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) {
				found = true;
				break;
			}
			i++;
		}
		Assert.IsTrue( found, "Search by _datetime failed" );

		// by <> datetime
		ret_crit = new RetrieveCriteria(
			(new TestObject()).Type,
			"( _datetime <> CAST('" + 
			_datetime_expected.Value.ToString( "yyyy-MM-dd HH:mm:ss.fff" ) + 
			"' as datetime))" );
		ret_crit.Perform();
		found = false;
		i = 0;
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) {
				found = true;
				break;
			}
			i++;
		}
		Assert.IsFalse( found, "Search by '<> _datetime' failed" );

		// by double
		ret_crit = new RetrieveCriteria(
			(new TestObject()).Type,
			"( _double = CAST(" + _double_expected.Value.ToString( "R" )
			.Replace( ",", "." ) +
			" as float ))" );
		ret_crit.Perform();
		found = false;
		i = 0;
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) {
				found = true;
				break;
			}
			i++;
		}
		Assert.IsTrue( found, "Search by _double failed" );

		// by NOT double
		ret_crit = new RetrieveCriteria(
			(new TestObject()).Type,
			"( _double <> CAST(" + _double_expected.Value.ToString( "R" )
				.Replace(",",".") + 
			" as float ))" );
		ret_crit.Perform();
		found = false;
		i = 0;
		while ( i < ret_crit.CountFound && !found ) {
			if ( ret_crit[i].ID == _id_expected ) {
				found = true;
				break;
			}
			i++;
		}
		Assert.IsFalse( found, "Search by '<> _double' failed" );
	}

	[Priority( 2 ), TestMethod()]
	public void SaveRetriveSearchTransTest()
	{
		PersistentTransaction trans;
		RetrieveCriteria ret_crit;

		// common variables
		TestObject obj;
		int _id_expected;
		string _name_expected;
		DateTime _stamp_expected;

		string _string_expected;
		int? _int_expected;
		bool? _boolean_expected;
		double? _double_expected;
		DateTime? _datetime_expected;


		obj = new TestObject();
		_name_expected = obj.Name = m_obj_name + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
		_int_expected = obj._int = 1234567890;
		_boolean_expected = obj._bool = true;
		_string_expected = obj._string = 
			@"Test строка (ї,ё) 1@№" + DateTime.Now.ToString();
		obj._datetime = DateTime.Now;
		_double_expected = obj._double = (double) 1 / 33;
		
		obj.Save();
		_id_expected = obj.ID;
		_stamp_expected = obj.Stamp;
		_datetime_expected = obj._datetime;

	    #region check props after save
	    Assert.AreEqual( _name_expected, obj.Name );
	    Assert.AreEqual( _int_expected, obj._int );
	    Assert.AreEqual( _boolean_expected, obj._bool );
	    Assert.AreEqual( _string_expected, obj._string );
	    Assert.IsTrue( DateTime.Equals(_datetime_expected, obj._datetime ));
	    Assert.IsTrue( DateTime.Equals( _stamp_expected, obj.Stamp ) );
	    Assert.AreEqual( _double_expected, obj._double );
	    #endregion

		// check property update in transaction
		_name_expected = obj.Name = m_obj_name + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
		_int_expected = obj._int = int.MaxValue;
		_boolean_expected = obj._bool = !obj._bool;
		_string_expected = obj._string = obj.Name;
		_datetime_expected = obj._datetime = DateTime.Now;
		_double_expected = obj._double = (double) 2 / 33;
		
		trans = new PersistentTransaction(obj, PersistentTransaction.ACTION.Save );
		trans.Process();

		_stamp_expected = obj.Stamp;
		_datetime_expected = obj._datetime;
		
		ret_crit = new RetrieveCriteria( obj.Type, "(ID = " + obj.ID );
		ret_crit.Perform();
		
		if( ret_crit.Count != 1 ) {
			Assert.Fail( "Update object in transaction failed!" );
		} else {
			#region check props
			Assert.AreEqual( _name_expected, ((TestObject)ret_crit[0]).Name );
			Assert.AreEqual( _int_expected, ((TestObject) ret_crit[0])._int );
			Assert.AreEqual( _boolean_expected, ((TestObject) ret_crit[0])._bool );
			Assert.AreEqual( _string_expected, ((TestObject) ret_crit[0])._string );
			Assert.IsTrue( DateTime.Equals( _datetime_expected, 
								((TestObject) ret_crit[0])._datetime ) );
			Assert.IsTrue( DateTime.Equals( _stamp_expected, 
								((TestObject) ret_crit[0]).Stamp ) );
			Assert.AreEqual( _double_expected, 
							((TestObject) ret_crit[0])._double );
			#endregion
		}
		
		// check property update in failed transaction
		_name_expected= obj.Name = m_obj_name + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
		_int_expected = obj._int = int.MaxValue;
		_boolean_expected = obj._bool = !obj._bool;
		_string_expected = obj._string = obj.Name;
		_datetime_expected = obj._datetime = DateTime.Now;
		_double_expected = obj._double = (double) 3 / 33;

		trans = new PersistentTransaction( obj, PersistentTransaction.ACTION.Save );
		TestObject fObj = new TestObject();
		fObj.FailOn = TestObject.FAIL.Save;
		trans.Add( fObj, PersistentTransaction.ACTION.Save );
		// run transaction
		try {
			trans.Process();
			Assert.Fail( "Exception wasn't raised" );
		} catch {/*catch exception that will be*/}
		// retrive object to check that nothing was changed
		ret_crit = new RetrieveCriteria( obj.Type, "(ID = " + obj.ID + ")" );
		ret_crit.Perform();

		if( ret_crit.Count != 1 ) {
			Assert.Fail( "Update object in transaction failed!" );
		} else {
			#region check props
			Assert.IsTrue( DateTime.Equals( _stamp_expected, 
							((TestObject) ret_crit[0]).Stamp ) );
			Assert.AreEqual( _name_expected, ((TestObject) ret_crit[0]).Name );
			Assert.AreEqual( _int_expected, ((TestObject) ret_crit[0])._int );
			Assert.AreEqual( _boolean_expected, ((TestObject) ret_crit[0])._bool );
			Assert.AreEqual( _string_expected, ((TestObject) ret_crit[0])._string );
			Assert.IsTrue( DateTime.Equals( _datetime_expected, 
							((TestObject) ret_crit[0])._datetime ) );
			Assert.AreEqual( _double_expected, ((TestObject) ret_crit[0])._double );
			#endregion
		}

		#region delete + failed
		trans = new PersistentTransaction();
		trans.Add( ret_crit[0], PersistentTransaction.ACTION.Delete );
		fObj = new TestObject();
		fObj.FailOn = TestObject.FAIL.Save;
		trans.Add( fObj, PersistentTransaction.ACTION.Save );
		try {
			trans.Process();
			Assert.Fail( "Exception wasn't raised" );
		} catch {/*catch exception that will be*/}
		ret_crit.Perform();
		// object must exist
		Assert.IsTrue( (ret_crit.CountFound == 1), 
						"rollbacked transaction didn't recover deleted object" );
		#endregion

		#region delete
		trans = new PersistentTransaction();
		trans.Add( ret_crit[0], PersistentTransaction.ACTION.Delete );
		trans.Process();
		ret_crit.Perform();
		// object must not exist
		Assert.IsTrue( (ret_crit.CountFound == 0),
						"transaction didn't delete object" );
		#endregion
	}


	/// <summary>
	/// A test for Search (CPersistentCriteria, ref IEnumerable&lt;CPersistentObject&gt;)
	/// </summary>
	[Priority( 3 ), TestMethod()]
	public void DeleteTest()
	{
		//RetrieveCriteria ret_crit = new RetrieveCriteria( 
		//        (new TestObject()).Type,
		//        "( name LIKE '" + m_obj_name + "%' )" );
		//ret_crit.Perform();
		//Assert.IsFalse( ret_crit.CountFound == 0,
		//                "Search for delete returned no objects" );

		DeleteCriteria del_crit = new DeleteCriteria(
			(new TestObject()).Type,
			"( name LIKE '" + m_obj_name + "%' )" );
		del_crit.Perform();

		//ret_crit = new RetrieveCriteria(
		//    (new TestObject()).Type,
		//    "( name LIKE '" + m_obj_name + "%' )" );
		//ret_crit.AsProxies = true;
		//ret_crit.Perform();
		//Assert.IsFalse( ret_crit.CountFound > 0, "Not all objects was deleted!" );
	}
}
}