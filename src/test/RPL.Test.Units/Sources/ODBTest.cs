// The following code was generated by Microsoft Visual Studio 2005.
// The test owner should check each test for validity.
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Text;
using System.Collections.Generic;
using RPL.Storage;
using RPL;
using System.Data.Common;
using System.IO;
using System.Runtime.Remoting.Proxies;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Channels;
using System.Net;
using System.Runtime.Remoting;
using System.Diagnostics;


namespace RPL.Test
{
	///<summary>This is a test class for RPL.Storage.ODB and is intended
	///to contain all RPL.Storage.ODB Unit Tests</summary>
	[TestClass()]
	public class ODBTest
	{
		private static string  m_obj_name = "VS_Load_Test";
		private TestContext testContextInstance;

		/// <summary>
		///Gets or sets the test context which provides
		///information about and functionality for the current test run.
		///</summary>
		public TestContext TestContext
		{
			get
			{
				return testContextInstance;
			}
			set
			{
				testContextInstance = value;
			}
		}
		#region Additional test attributes
		// 
		//You can use the following additional attributes as you write your tests:
		//
		
		//Use ClassInitialize to run code before running the first test in the class
		
		[ClassInitialize()]
		public static void MyClassInitialize(TestContext testContext)
		{
			//remoting_config();
			//CPersistenceBroker.Factory = new CFactory( "tcp://localhost:43667/RPL.Server.rem" );

			//CTestObject obj = new CTestObject();
			//obj.Name = "new";
			//obj.Save();

			//CRetrieveCriteria ret_crit = new CRetrieveCriteria( CTestObject.type() );
			//ret_crit.Perform();


			DbProviderFactory prov = DbProviderFactories.GetFactory( "System.Data.SqlClient" );
			DbConnection con = prov.CreateConnection();
			con.ConnectionString = "Data Source=CORP;Initial Catalog=LineNBU;Persist Security Info=True;User ID=sa;Password=12345";
			ODB adodb = new ODB();
			CPersistenceBroker.Instance.Connect( con, adodb );
		}
		
		//Use ClassCleanup to run code after all tests in a class have run
		
		[ClassCleanup()]
		public static void MyClassCleanup()
		{
			RPL.CPersistenceBroker.Instance.Dispose();
		}
		
		//Use TestInitialize to run code before running each test
		//
		//[TestInitialize()]
		//public void MyTestInitialize()
		//{
		//}
		//
		//Use TestCleanup to run code after each test has run
		//
		//[TestCleanup()]
		//public void MyTestCleanup()
		//{
		//}
		//
		#endregion

		[Priority( 1 ), TestMethod()]
		public void SaveRetriveSearchTest()
		{
			// common variables
			CTestObject obj;
			CRetrieveCriteria ret_crit;
			int _id_expected;
			string _name_expected;
			DateTime _stamp_expected;

			string _string_expected;
			int _int_expected;
			bool _boolean_expected;
			double _double_expected;
			DateTime _datetime_expected;


			obj = new CTestObject();
			_name_expected = obj.Name = m_obj_name + DateTime.Now.ToString();
			_int_expected = obj._int = 1234567890;
			_boolean_expected = obj._boolean = true;
			_string_expected = obj._string = @"Test строка (ї,ё) 1@№" + DateTime.Now.ToString();
			obj._datetime = DateTime.Now;
			_double_expected = obj._double = 1234567890.123456789012345;
			//create parent object
			CTestObject parent_obj = new CTestObject();
			parent_obj.Name = _name_expected;
			parent_obj._int = _int_expected;
			//end
			obj.AddParent( parent_obj );
			obj.Save(); //save object
		

			//save data here because of change that can be during conversion to sql pressision
			_datetime_expected = obj._datetime;
			_id_expected = obj.ID;
			_stamp_expected = obj.Stamp;

			#region check props after save
			Assert.AreEqual( _name_expected, obj.Name );
			Assert.AreEqual( _int_expected, obj._int );
			Assert.AreEqual( _boolean_expected, obj._boolean );
			Assert.AreEqual( _string_expected, obj._string);
			Assert.IsTrue( DateTime.Equals( _stamp_expected, obj.Stamp ));
			Assert.AreEqual( _double_expected, obj._double );
			//parent check
			foreach (CPersistentObject link_obj in obj.GetParents ) {
				Assert.AreEqual(_name_expected, link_obj.Name );
			}
			#endregion
			
			//by string equality
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "(_string = '" + _string_expected +"')" );
			ret_crit.Perform();
			Assert.IsTrue( ( ret_crit.CountFound == 1 ), "Search by Name failed");
			Assert.AreEqual( _id_expected, ret_crit[0].ID );
			//check properties
			Assert.AreEqual( _name_expected, ((CTestObject)ret_crit[0]).Name );
			Assert.AreEqual( _int_expected, ((CTestObject)ret_crit[0])._int );
			Assert.AreEqual( _boolean_expected, ((CTestObject)ret_crit[0])._boolean );
			Assert.AreEqual( _string_expected, ((CTestObject)ret_crit[0])._string );
			Assert.AreEqual( _stamp_expected, ((CTestObject)ret_crit[0]).Stamp );
			Assert.AreEqual( _datetime_expected, ((CTestObject)ret_crit[0])._datetime );
			Assert.AreEqual( _double_expected, ((CTestObject)ret_crit[0])._double );

			//by LIKE
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _string LIKE '%" + _string_expected.Substring( 2, _string_expected.Length - 2 ) + "%')" );
			ret_crit.Perform();
			Assert.IsTrue( ( ret_crit.CountFound == 1 ), "Search by Name failed");
			Assert.AreEqual( _id_expected, ret_crit[0].ID );
			
			//by string NOT LIKE
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _string NOT LIKE '%" + _string_expected.Substring( 2, _string_expected.Length - 2 ) + "%')" );
			ret_crit.Perform();
			bool found = false;
			int i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsFalse( found, "'NOT LIKE' failed" );

			//by ID
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( ID = " + _id_expected +")" );
			ret_crit.Perform();
			Assert.IsTrue( ( ret_crit.CountFound == 1 ), "Search by id failed");
			Assert.AreEqual( _id_expected, ret_crit[0].ID );

			//by NOT ID
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( ID <> " + _id_expected +")" );
			ret_crit.Perform();
			found = false;
			i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsFalse( found, "search by '<> ID' condition failed" );
			

			//by bit
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _boolean = CAST(" + (_boolean_expected ? 1 : 0) + " as bit))" );
			ret_crit.Perform();
			found = false;
			i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsTrue( found, "search by boolean failed" );

			//by <> bit
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _boolean <> CAST(" + (_boolean_expected ? 1 : 0) + " as bit))" );
			ret_crit.Perform();
			found = false;
			i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsFalse( found, "search by '<> boolean' condition failed" );

			#region
			//by int
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _int = " + _int_expected + ")" );
			ret_crit.Perform();
			found = false;
			i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsTrue( found, "search by int failed" );

			//by <> bit
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _int <> " + _int_expected + ")" );
			ret_crit.Perform();
			found = false;
			i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsFalse( found, "search by '<> int' condition failed" );
			#endregion


			//by datetime
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _datetime = CAST('" + _datetime_expected.ToString( "yyyy-MM-dd HH:mm:ss.fff" ) + "' as datetime))" );
			ret_crit.Perform();
			found = false;
			i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsTrue( found, "Search by datetime failed" );

			// by <> datetime
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _datetime <> CAST('" + _datetime_expected.ToString( "yyyy-MM-dd HH:mm:ss.fff" ) + "' as datetime))" );
			ret_crit.Perform();
			found = false;
			i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsFalse( found, "Search by '<> datetime' condition failed" );

			//by double
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _double = CAST(" + _double_expected.ToString("R") + " as float ))" );
			ret_crit.Perform();
			found = false;
			i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsTrue( found, "Search by double failed" );

			//by NOT double
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _double <> CAST(" + _double_expected.ToString( "R" ) + " as float ))" );
			ret_crit.Perform();
			found = false;
			i = 0;
			while ( i < ret_crit.CountFound && !found ) {
				if ( ret_crit[i].ID == _id_expected )
					found = true;
				i++;
			}
			Assert.IsFalse( found, "Search by '<> double' condition failed" );
		}

		[Priority( 2 ), TestMethod()]
		public void SaveRetriveSearchTransTest()
		{
			CPersistentTransaction trans;
			CRetrieveCriteria ret_crit;
			CUpdateCriteria upd_crit;
			CDeleteCriteria del_crit;

			//common variables
			CTestObject obj;
			int _id_expected;
			string _name_expected;
			DateTime _stamp_expected;

			string _string_expected;
			int _int_expected;
			bool _boolean_expected;
			double _double_expected;
			DateTime _datetime_expected;


			obj = new CTestObject();
			_name_expected = obj.Name = m_obj_name + DateTime.Now.ToString();
			_int_expected = obj._int = 1234567890;
			_boolean_expected = obj._boolean = true;
			_string_expected = obj._string = @"Test строка (ї,ё) 1@№" + DateTime.Now.ToString();
			obj._datetime = DateTime.Now;
			_double_expected = obj._double = 1234567890.123456789012345;

			#region add/retrive trans
			trans = new CPersistentTransaction();
			//trans.Add( obj, CPersistentTransaction.Actions.actSave );
			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _string = '" + _string_expected +"')" );
			trans.Add( ret_crit );
			trans.Process();

			//save data here becuse of change that can be during conversion to sql pressision
			_datetime_expected = obj._datetime;
			_id_expected = obj.ID;
			_stamp_expected = obj.Stamp;

			#region check props after save
			Assert.AreEqual( _name_expected, obj.Name );
			Assert.AreEqual( _int_expected, obj._int );
			Assert.AreEqual( _boolean_expected, obj._boolean );
			Assert.AreEqual( _string_expected, obj._string );
			Assert.IsTrue( DateTime.Equals( _stamp_expected, obj.Stamp ) );
			Assert.AreEqual( _double_expected, obj._double );
			#endregion

			//by string equality
			Assert.IsTrue( (ret_crit.CountFound == 1), "search by Name failed" );
			Assert.AreEqual( _id_expected, ret_crit[0].ID );
			#endregion

			#region single object manipulation
			#region update crireria
			trans = new CPersistentTransaction(  );
			upd_crit = new CUpdateCriteria( CTestObject.type() );
			upd_crit.Where = ret_crit.Where;
			upd_crit.Properties.Add(new CPersistentProperty("_int", 9999));
			trans.Add( upd_crit );
			trans.Add(ret_crit);
			trans.Process();
			Assert.IsTrue( (ret_crit.CountFound > 0), "search by Name failed" );
			Assert.AreEqual( _id_expected, ret_crit[0].ID );
			Assert.IsTrue( ((CTestObject)ret_crit[0])._int == 9999, "update object property failed");
			#endregion

			#region update criteria + exception
			trans = new CPersistentTransaction();
			upd_crit = new CUpdateCriteria( CTestObject.type() );
			upd_crit.Where = ret_crit.Where;
			upd_crit.Properties.Add( new CPersistentProperty( "_int", 9 ) );
			trans.Add( upd_crit );
			trans.Add( ret_crit );
			CRetrieveCriteria ret_crit_f = new CRetrieveCriteria( CTestObject.type() );
			ret_crit_f.Where = "Fail";
			trans.Add(ret_crit_f);
			// run transaction
			try {
				trans.Process();
				Assert.Fail("Exception wasn't raised");
			} catch {/*catch exception that will be*/}
			//retrive objects to chack that nothing was changed
			ret_crit.Perform();
			Assert.IsTrue( (ret_crit.CountFound == 1 ), "search by Name failed" );
			Assert.AreEqual( _id_expected, ret_crit[0].ID );
			//value must not be those that was assigned in failed transaction
			Assert.IsFalse( ((CTestObject)ret_crit[0])._int == 9, "update object property failed" );
			#endregion

			#region delete + failed
			trans = new CPersistentTransaction();
			trans.Add( ret_crit[0], CPersistentTransaction.Actions.actDelete );
			trans.Add( new CRetrieveCriteria( CTestObject.type(), "Failed" ));
			try {
				trans.Process();
				Assert.Fail("Exception wasn't raised");
			} catch {/*catch exception that will be*/}
			ret_crit.Perform();
			//object must exist
			Assert.IsTrue( (ret_crit.CountFound == 1 ), "rollbacked transaction didn't recover deleted object" );
			Assert.AreEqual( _id_expected, ret_crit[0].ID );
			#endregion
			#endregion

			#region multiple object manipulation
			trans = new CPersistentTransaction();
			_int_expected = -1;
			for ( int i = 0; i < 99; i++ ) {
				CTestObject t_obj = new CTestObject();
				t_obj._int = _int_expected;
				t_obj._stream = new FileStream( @"c:\ntldr", FileMode.Open, FileAccess.Read , FileShare.Read);
				trans.Add( t_obj, CPersistentTransaction.Actions.actSave );
			}
			trans.Process();

			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( _int = " + _int_expected + ")" );
			ret_crit.AsProxies = true;
			ret_crit.Perform();
			int count = ret_crit.CountFound;

			trans = new CPersistentTransaction();
			del_crit =new CDeleteCriteria(CTestObject.type(), "( _int = " + _int_expected + ")");
			trans.Add(del_crit);
			trans.Add( new CRetrieveCriteria( CTestObject.type(), "Failed" ));
			try {
				trans.Process();
				Assert.Fail("Exception wasn't raised");
			} catch {/*catch exception that will be*/}
			ret_crit.Perform();
			Assert.IsTrue(count == ret_crit.CountFound, "During transaction something wasn't rollbacked");
			#endregion
		}


		///<summary>A test for Search (CPersistentCriteria, ref IEnumerable&lt;CPersistentObject&gt;)</summary>
		[Priority( 3 ), TestMethod()]
		public void DeleteTest()
		{
			CRetrieveCriteria ret_crit = new CRetrieveCriteria( CTestObject.type(), "( name LIKE '" + m_obj_name + "%' )" );
			ret_crit.Perform();
			Assert.IsFalse( ret_crit.CountFound == 0, "Search for delete returned no objects" );

			CDeleteCriteria del_crit = 
				new CDeleteCriteria( CTestObject.type(), "( name LIKE '" + m_obj_name + "%' )" );
			del_crit.Perform();

			ret_crit = new CRetrieveCriteria( CTestObject.type(), "( name LIKE '" + m_obj_name + "%' )" );
			ret_crit.AsProxies = true;
			ret_crit.Perform();
			Assert.IsFalse( ret_crit.CountFound > 0, "Not all objects was deleted!" );
		}

		private class CFactory : IBrokerFactory
		{
			private string m_uri;

			public CFactory( String uri ) { m_uri = uri; }
			
			CPersistenceBroker IBrokerFactory.CreateInstance()
			{
				return (CPersistenceBroker) (new CustomProxy(
				        m_uri, typeof(CPersistenceBroker))).GetTransparentProxy();
			}

			private class CustomProxy : RealProxy
			{
				private String m_uri;
				private String m_clientID;
				private IMessageSink m_messageSink;

				public override IMessage Invoke( IMessage msg )
				{
					msg.Properties["__Uri"] = m_uri;

					// pass the client's unique identifier as part of the call context
					LogicalCallContext callContext = (LogicalCallContext)
												(msg.Properties["__CallContext"]);
					callContext.SetData( "__ClientID", m_clientID );

					return m_messageSink.SyncProcessMessage( msg );
				}
				public CustomProxy( String uri, Type type ) : base( type )
				{
				    // store uri of remote service
				    m_uri = uri;

				    // pass through registered chanels
				    foreach ( IChannel channel in ChannelServices.RegisteredChannels ) {
				       // and try to find chanel, that can be used to
				       // create message sink for given uri
				       IChannelSender sender = (IChannelSender)channel;
				       if ( sender != null ) {
				          // check for messaging protocol
				          if ( sender.ChannelName == "tcp" ) {
				             // try to create message sink for specified uri
				             string objectUri = string.Empty;
				             m_messageSink = sender.CreateMessageSink( m_uri, null, out objectUri );
				             // all right, can return
				             if ( m_messageSink != null ) break;
				          }
				       }
				    }
				    if ( m_messageSink == null ) throw new Exception( 
				          "No channel found for " + m_uri );

				    // create a unique identifier
				    // здесь необходимо получить IP и порт "серверной" части
				    // этого экземпляра клиента (делается это через сторонний
				    // компониент, который создает мост клиент-сервер)
				    m_clientID = "tcp://" + Dns.GetHostName() + ":" + "8888" + 
				              "/" + "310001" + Guid.NewGuid().ToString();
				}
			}
		}

		private static void remoting_config()
		{
			// activate client chanel
			BinaryServerFormatterSinkProvider srvProv = 
				new BinaryServerFormatterSinkProvider();
			srvProv.TypeFilterLevel = System.Runtime.Serialization.Formatters.TypeFilterLevel.Full;
			BinaryClientFormatterSinkProvider cliProv =
			    new BinaryClientFormatterSinkProvider();
			System.Collections.IDictionary props = new System.Collections.Hashtable();
			props["port"] = 8888;

			System.Runtime.Remoting.Channels.Tcp.TcpChannel chan = new System.Runtime.Remoting.Channels.Tcp.TcpChannel( props, cliProv, srvProv );
			ChannelServices.RegisterChannel( chan, false );

			RemotingConfiguration.RegisterActivatedServiceType( typeof( CTestObject ) );
			RemotingConfiguration.RegisterActivatedServiceType( typeof( SqlStream ) );
		}
	}
}
